<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Perl vs Ruby</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="A tech blog about ruby, code, mongodb, golang and other stuff.">
    <link rel="canonical" href="http://squarism.com//2011/03/25/perl-vs-ruby/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">Squarism</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          <a class="page-link" href="/about/">About</a>
        
          
        
          
        
          <a class="page-link" href="/about/index.html">About</a>
        
          <a class="page-link" href="/questions/index.html">Questions I Have</a>
        
          <a class="page-link" href="/tatris/index.html">Tatris - A Tetris Clone</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Perl vs Ruby</h1>
    <p class="meta">Mar 25, 2011 â€¢ Posted by: chris</p>
  </header>

  <article class="post-content">
  <p><img src="/uploads/2011/03/pearl-290x300.png" alt="" title="pearl" width="290" height="300" class="alignright size-medium wp-image-1085" /><br />
This isn't like Perl vs Ruby: FIGHT!  This is more like walking vs running: COMPARE!.  They will both get you there, just in different times and sweat amounts.  :)</p>
<p>I stopped doing Perl in about 2002 but not because I hated Perl.  I stopped doing Perl because started learning Java.  Java was where the jobs were.  Since all that, I know I've become a better developer so a lot of this is situational to me and not a reflection on the language.  Without a control group, you can't say that the language has made me any different.  I've learned things (not all things) from each language, environment and community as I've bounced around.  No doubt, I'm Ruby-biased so please post comments, corrections and better ways of doing things in Perl so that I'm the most accurate I can be.  Recently it's popped back up at work and I needed a refresher but </p>
<p>Ok, enough about that.  I'm here to compare how you do things in each language.  Ruby is all about blocks, syntax sugar and a very different community than Perl.  Both share many idealistic values (such as <em>there's more than one way to do something</em>) and <a href="http://www.rootr.net/rubyfaq-2.html">Ruby was inspired a lot by Perl</a>.  So this isn't a battle but more of a Rosetta stone.<br />
<a id="more"></a><a id="more-1073"></a></p>
<h2>Methods/Functions</h2>
<p><br />
In both languages you can skip the return statement.&lt;/p&gt;
&lt;pre lang="perl"&gt;
sub add {<br />
  # return statement is not needed<br />
  $<em>[0] + $</em>[1];<br />
}&lt;/p&gt;</p>
<p>print add(1,2) . "\n";<br />
# 3<br />
</p>
<p>Notice that we have to print a newline.  In perl, there's no println or puts.  In Perl 6, there will be a say function which will do a print with a newline.  But <a href="http://en.wikipedia.org/wiki/Perl_6">Perl 6 is not out</a>.</p>
<p>A neat trick is the $_ variable which means "an array of arguments".  You can't do this in Ruby so you have to explicitly define arguments otherwise you raise an ArgumentError.  $_ is a little bit line-noisy but that's the way I remember Perl.</p>
<pre lang="ruby">
def add(a,b)<br />
  a + b<br />
end<br />
puts add(1,2)<br />
# =&gt; 3<br />
</pre>
<p>&lt;/p&gt;</p>
<p>So both of these functions do the same thing (although horrible and useless).  Both can't take three numbers: add(1,2,3).  In Ruby, you get a run-time ArgumentError exception.  In Perl, the third number "3" is thrown away and it still adds 1 + 2.  Of course, this isn't how you would do this in Ruby.  You would use the splat operator and add could take any number of arguments.  You can do the same thing in Perl but it's not automatic or nearly as clean.</p>
<pre lang="perl">
sub add {<br />
  $total = 0;<br />
  foreach $number (@_) {<br />
    $total = $number + $total;<br />
  }<br />
  $total;<br />
}
<p>print add(1,2,3) . "\n";<br />
# 6<br />
print add(1,2,3,4) . "\n";<br />
# 10<br />
</p>
<p>Now now our Perl function can take any numbers and add them up.  This is how we'd do this in Ruby.</p>
<pre lang="ruby">
# thank you PJK in comments<br />
def add(*arguments)<br />
  arguments.inject(&amp;:+)<br />
end<br />
puts add(1,2,3)<br />
puts add(1,2,3,4)<br />
</pre>
<p>We can even just pass one number in and it will work in both languages.  I think both are fairly readable except for the fact that Perl is starting to look line-noisy with the @_ and $ all over the place.  The advantage here is that you know what kind of object it is by looking at the code.  The disadvantage is, Ruby doesn't care because of <a href="http://en.wikipedia.org/wiki/Duck_typing">duck-typing</a>.</p>
<h2>Method weirdness</h2><br />
One thing I forgot or never knew is how Perl does it's lifecycle.  As I'm writing this, I'm redefining functions (methods) and they aren't doing what they are supposed to.  For example, I would expect this to print muffin:<br />
<code>$ perl -e 'sub food { print "muffin\n"; } food;'</code>
<p>And it does.  But I would expect this to print muffin and then asphault:<br />
<code>perl -e 'sub food { print "muffin\n"; } food; sub food { print "asphault\n"} food;'</code></p>
<p>But it prints asphault twice.</p>
<p>You can get around this by using Sub::Override but omg this is horrifying.  I have to download a CPAN module, install it (which is easy) and then my code looks like this:<br />
<code>perl -e 'use Sub::Override;  sub food { print "muffin\n"; } food; my $override = Sub::Override-&gt;new( food =&gt; sub { print "asphault\n"}); food;'</code></p>
<p>This is not how Ruby works and I think that's bad because it makes more sense in Ruby.  If I redefine food(), then it should be redefined at runtime.  Ruby version:<br />
<code>ruby -e 'def food() puts :muffin end; food; def food() puts :asphault end; food;'</code></p>
<p>Note that writing ruby one-liners is messy as crap.  This is also horrifying!  I can't make it much better by using semi-colons:<br />
<code>ruby -e 'def food;puts "muffin";end; food; def food;puts "asphault";end; food;'</code></p>
<p>Perl one-liners are nicer.  Ruby method redefinition in a normal file/program is nicer.</p>
<h2>Environment and Libraries</h2><br />
Gems and perl modules are almost the same thing.  I like Ruby's gem command for interactive installation more than the CPAN shell but both are about the same if you install from a tarball.  However, ruby gems don't need to be extracted.  Perl has a lot more modules but I never got far enough with Perl to learn what killer libraries are out there.  <a href="http://ruby-toolbox.com/">Ruby toolbox</a> has what I think is a killer list of libraries that get really high-level functionality done quick.  For example, the savon library for webservices does quite a lot of work in just a few lines of <em>your code</em>.
<p>Perl modules have namespaces which is a O_o moment for me in Ruby.  I've never run into a namespace collision but if you've ever taken a look at what is actually in scope, I don't think this is going to scale forever.  I guess as long as people don't all use the same CONFIG symbols and stick to modules as namespaces, everything will be ok.  I still would prefer an option to import library.module or Library::Module or something like that.<br />
<code><br />
$ ruby -e 'puts Symbol.all_symbols.size'<br />
1562<br />
$ ruby -e 'require "rails"; puts Symbol.all_symbols.size'<br />
3706<br />
$ ruby -e 'require "rails"; require "savon"; puts Symbol.all_symbols.size'<br />
5976<br />
$ ruby -e 'require "rails"; require "savon"; require "wirble"; puts Symbol.all_symbols.size'<br />
6078<br />
</code></p>
<p>Perl wins in this regard.</p>
<h2>Deployment</h2><br />
Massive generalizations incoming.  I can't cover every edge case.  So I'll just say that Perl is installed everywhere.  Ruby is installed someplaces.  On Windows, neither is there and both are a pain but not because of the interpreter itself but because you need a real dev environment (gcc etc).  DevKit in Windows might solve both problems.  I've followed EngineYard's lead and gotten Ruby on Windows up and running using their installer and DevKit.  But I haven't done it multiple times because it's a pretty new initiative by them.
<p>So the Perl that ships with the OS is probably ok.  The new hotness right now seems to be some version of 5.10 which 10.10 comes with.  Ubuntu at least gives you 5.10 if you do an apt-get but Ruby is completely unusable.  If you're not a rubyist, 1.9.1 is taboo.  It doesn't run rails 3 and 1.9.2 is pretty much the current version (although a little bleeding edge).  I use it as my main now and haven't had any major gotchas.  On mac, Perl is probably broken.  On mac, Ruby is definitely broken, it ships with 1.8.6 as of 10.6.6 and that's completely old and busted.  So in either case, you probably have some work to do but Ubuntu/Linux gives Perl the edge.</p>
<p>RVM is absolutely awesome, it allows you to switch interpreters at will, create/switch collections of gems (modules) and installs the interpreter in your home directory so that you don't have to sudo everything.  If your home directory floats with you on a network, then it's even more awesome because your ~/.rvm directory has your entire dev environment exported over NFS or whatever.  But RVM is not the default way of installing ruby, it is not integrated into your OS package manager and it does not run on Windows.  So you have to discount RVM.</p>
<h2>Powah</h2><br />
Ruby can do more in one line than Perl can do.  Who cares?  Well it speeds up development time and reduces bugs, at least in theory.  I know there's way more to development than syntax but there isn't a whole lot more to putting a smile on a developer's face when he thinks about how hard a problem <em>could have been</em>.
<p>Ok, so let's take a bunch of strings and capitalize them.</p>
<pre lang="perl">
# capitalize all in array<br />
@list = qw(one two red blue);<br />
print "Capitalize all in array: ";<br />
foreach $item (@list) {<br />
  print uc $item . " ";<br />
}<br />
print "\n";<br />
</pre><br />
This gives us: <code>Capitalize all in array: ONE TWO RED BLUE</code>
<p>Now let's only capitalize colors.  Taken from <a href="http://langref.org/all-languages/lists/access/list-intersection">langref.org</a>.</p>
<pre lang="perl">
# capitalize only colors<br />
@colors = qw{red blue};<br />
@seen{@list} = ();<br />
for (@colors) {<br />
  push(@capital_colors, uc $_) if exists($seen{$_});<br />
}<br />
print "Capitalize only colors in array: ";<br />
print join(', ', @capital_colors) . "\n";<br />
</pre><br />
This gives us: <code>Capitalize only colors in array: RED, BLUE</code>.  Not great.  Lots of code, lots of weird symbols that won't make sense to you in a year (imo).  What is <code>@seen{@list} = ();</code> all about?  Even if you explain it, why do I have to do all that for what Ruby does with include?().  We'll get to that in a second.
<p>First, let's capitalize (actually uppercase) all words in an array in Ruby:</p>
<pre lang="ruby"># capitalize all in array<br />
list = %w(one two red blue)<br />
capital_colors = list.collect {|item| item.upcase }<br />
puts capital_colors.join(", ")</pre>
<p>Ok 4 vs 7 lines.  And we can shorten it too 3 lines.</p>
<pre lang="ruby">
# capitalize all in array, shorter<br />
list = %w(one two red blue)<br />
puts list.collect {|item| item.upcase }.join(", ")<br />
</pre>
<p>Shorter still:</p>
<pre lang="ruby"># capitalize all in array, even shorter<br />
list = %w(one two red blue)<br />
puts list.map(&amp;:upcase).join(", ")<br />
</pre>
<p>Ok, what about only capitalizing color words then?  How much different does it look than Perl?</p>
<pre lang="ruby">
# capitalize only colors<br />
colors = %w(red blue)<br />
puts (list &amp; colors).map(&amp;:upcase).join(", ")<br />
</pre>
<p>So is this more readable?  Not really.  The &amp; method of an Array in Ruby is pretty terse and cryptic just like Perl's shortcuts.  <a href="http://ruby-doc.org/core/classes/Array.html#M000274">But it is documented in the stdlib</a>.  But if we want to make it a little more readable then we can do this:</p>
<pre lang="ruby">
# less terse<br />
colors = %w(red blue)<br />
capital_colors = Array.new<br />
list.each do |item|<br />
  capital_colors  &lt;&lt; item.upcase if colors.include?(item)<br />
end<br />
puts capital_colors.join ", "<br />
</pre>
<p>How ugly is it?  How long is it?  Which is better?  Well even the longer Ruby form of capitalizing colors is 7 lines including the comment whereas the Perl version is 8.  Well who cares?  The Ruby version is way more readable in either form.  I can add comments like "for each item in the list that intersects, capitalize and join with commas".  With the Perl version, I would have to explain what the temp variable is.  Perhaps this is a comfort opinion as a Perl person would wonder what the heck &amp;:upcase means.  In any event, Ruby has methods that are at least named something meaningful and you can chain them along like Python.  However, unlike Python, Ruby has blocks.  And blocks are extremely powerful which is also why the Perl person wouldn't understand why &amp;:upcase is so awesome.</p>
<p>Perl really only has one way to go through an Array.  You loop through it.  Ruby has that but more.  You can loop plainly with .each() but you can also pass a block in to do something.  You can even return a new Array with .collect() or .map().  But really it's not about looping over the Array that is the important part.  The distinguishing feature (again) in Ruby is blocks.  It's the fact that you can pass a block to .each() and .collect() and avoid having to iterate over and over again.  It's the fact that a block can be passed to a file iterator, a database result set, a hash and an array and they all acts the same.  For a really good presentation, you should check out <a href="http://blog.extracheese.org/2010/02/python-vs-ruby-a-battle-to-the-death.html">Gary Bernhardt's presentation</a> he did about Ruby to a room full of Python people.  Also, check out his <a href="http://peepcode.com/products/play-by-play-bernhardt">Play-by-Play at Peepcode</a>.</p>
<p>In any event, this contrived example is just the beginning.  Ruby gives you crazy powah and not just iteration.</p>
<h2>REPL</h2><br />
Ruby has a shell called IRB that gives you REPL hotness.  Perl can do an eval loop too like this:<br />
<code># put into .bashrc<br />
alias 'perl-repl'='perl -MData::Dumper -MTerm::ReadLine -e '\''$r = Term::ReadLine-&gt;new(1);while(defined($_ = $r-&gt;readline("code: "))){$ret=Dumper(eval($_));$err=$@;if($err ne ""){print $err;}else{print $ret;}}'\'''</code><br />
But is that good?  Irb comes with Ruby.  It's not only part of it but there are gems that extend it.  Irb has autocompletion (like how you hammer the tab key in bash), colors and introspection tricks like the following.  Let's say I have a new library (gem) that I'm not familiar with.  I fire up irb:<br />
<code>$ irb</code><br />
Now in irb, I can do stuff like this (colors not shown):
<pre lang="ruby">
&gt;&gt; require 'plucky'<br />
=&gt; false<br />
&gt;&gt; Plucky.class<br />
=&gt; Module<br />
&gt;&gt; Plucky.public_methods<br />
=&gt; [:!, :!, :!, :, :, :=&gt;, :, :, :, :, :, :__id__, :__send__, :ai, :ancestors<br />
</pre><br />
I have no idea what <a href="https://github.com/jnunemaker/plucky">Plucky</a> is or what it does.  So I ran public_methods to see what it does.  The list of public_methods goes off the screen to the right.  There's a ton of them because it's inheriting from the class Object and who knows what else.  But following a trick found on stackoverflow, I can monkey-patch the Object class to only show what the difference is between it and Object (ruby has single inheritance so there's no chain).  So I put this in my .irbrc:
<pre lang="ruby">class Object<br />
  # Return only the methods not present on basic objects<br />
  def interesting_methods<br />
    if self.is_a? Class<br />
      (self.public_methods - Object.public_methods).sort<br />
    else<br />
      if self.is_a? Module<br />
        (self.public_methods - Module.public_methods).sort<br />
      else<br />
        (self.public_methods - Object.new.public_methods).sort<br />
      end<br />
    end<br />
  end<br />
end<br />
</pre><br />
And now I can do this in irb:
<pre lang="ruby">
&gt;&gt; require 'plucky'<br />
=&gt; true<br />
&gt;&gt; Plucky.interesting_methods<br />
=&gt; [:to_object_id]<br />
&gt;&gt; Plucky.public_methods.size<br />
=&gt; 103<br />
&gt;&gt; Plucky.interesting_methods.size<br />
=&gt; 1<br />
</pre>
<p>Ok, so there's 1 method that is possibly interesting.  But what is this Plucky object?  If I call .class on it, I find out that it's a Module which is being handled in the .irbrc snippet above.  Well, a module usually doesn't have much use by itself.  Usually a module includes classes that actually does stuff.  So let's try to find a class by looking at Plucky's constants:<br />
<code>Plucky.constants<br />
[:Extensions, :CriteriaHash, :OptionsHash, :Query, :Version, :Pagination]<br />
</code></p>
<p>For each of those, we can see what it is with the .class method.</p>
<pre lang="ruby">Plucky::Extensions.class<br />
=&gt; Module<br />
&gt;&gt; Plucky::Query.constants<br />
=&gt; [:OptionKeys]<br />
Plucky::Query::OptionKeys<br />
=&gt; [:select, :offset, :order, :fields, :skip, :limit, :sort,<br />
:hint, :snapshot, :batch_size, :timeout]<br />
</pre>
<p>Ok so Query looks interesting.  Let's take a look at it.</p>
<pre lang="ruby">&gt;&gt; Plucky::Query.interesting_methods<br />
=&gt; [:def_delegator, :def_delegators, :def_instance_delegator,<br />
:def_instance_delegators, :delegate, :instance_delegate]<br />
</pre>
<p>Well, that's not very interesting.  Let's try creating and instance of Plucky::Query.</p>
<pre lang="ruby">&gt;&gt; Plucky::Query.new.interesting_methods<br />
ArgumentError: wrong number of arguments (0 for 1)<br />
</pre>
<p>Ok, apparently it wants a parameter.  It's just make up something.</p>
<pre lang="ruby">Plucky::Query.new("muffins").interesting_methods<br />
=&gt; [:[], :[], :all, :all?, :any?, :chunk, :collect, :collect_concat, :collection,<br />
:count, :criteria, :cycle, :detect, :drop, :drop_while, :each, :each_cons,<br />
:each_entry, :each_slice, :each_with_index, :each_with_object,<br />
:empty?, :entries, :exist?, :exists?, :explain, :fields, :fields?, :find,<br />
:find_all, :find_each, :find_index, :find_one, :first, :flat_map, :grep,<br />
:group_by, :ignore, :include?, :inject, :last, :limit, :map, :max, :max_by,<br />
:member?, :merge, :min, :min_by, :minmax, :minmax_by, :none?,<br />
:object_ids, :offset, :one?, :only, :options, :order, :paginate, :partition,<br />
:per_page, :reduce, :reject, :remove, :reverse, :reverse_each, :select,<br />
:simple?, :size, :skip, :slice_before, :sort, :sort_by, :take, :take_while,<br />
:to_a, :to_hash, :to_set, :update, :where, :zip]<br />
</pre>
<p>Now we're getting somewhere.  Looks like Query mixes in Enumerable (there's an each method and others).  Let's check:</p>
<pre lang="ruby">&gt;&gt; Plucky::Query.included_modules<br />
=&gt; [Enumerable, Wirble::Shortcuts, PP::ObjectMixin, Kernel]<br />
</pre>
<p>Wirble::Shortcuts and PP::ObjectMixin don't count because we're in irb and those are irb mixins specific to "pretty print" and wirble which just make irb more pretty.  So Enumerable and Kernel are the modules that Query uses.  Enumerable most likely contains each.  Let's write a quick script to find out.</p>
<pre lang="ruby"># what methods does Enumerable give you?<br />
class Foo; end<br />
base_methods = Foo.new.public_methods<br />
class Foo; include Enumerable; end
<p>enumerable_methods = Foo.new.public_methods<br />
special_methods = enumerable_methods - base_methods</p>
<p># monkey patch for interesting_methods outside of IRB<br />
class Object<br />
  # Return only the methods not present on basic objects<br />
  def interesting_methods<br />
    if self.is_a? Class<br />
      (self.methods - Object.methods).sort<br />
    else<br />
      if self.is_a? Module<br />
        (self.methods - Module.methods).sort<br />
      else<br />
        (self.methods - Object.new.methods).sort<br />
      end<br />
    end<br />
  end<br />
end</p>
<p>require 'plucky'<br />
plucky_methods = Plucky::Query.new("muffins").interesting_methods</p>
<p>class Foo; include Kernel; end<br />
kernel_methods = Foo.new.methods</p>
<p># gets close but no cigar<br />
puts (plucky_methods - special_methods - kernel_methods).join(",")<br />
</p>
<p>This outputs:<br />
<code><br />
[],[]=,all,collection,criteria,each,empty?,exist?,exists?,explain,<br />
fields,fields?,find_each,find_one,ignore,last,limit,merge,<br />
object_ids,offset,only,options,order,paginate,per_page,<br />
remove,reverse,simple?,size,skip,to_hash,update,where<br />
</code><br />
Unfortunately, this isn't quite right according to `ri Plucky::Query`.  But at least we have a clue as to what this thing is like.  If we hit up his <a href="https://github.com/jnunemaker/plucky/blob/master/test/plucky/test_query.rb">tests directory in the source</a>, we can see we were getting close.</p>
<p>The point of this extremely long section is all about REPL.  Here we are playing around with an API directly with no knowledge of it because we have IRB.  We at least learned that it has something to do with an iterator, fields and finding things.  That's pretty close to what is shown in <a href="http://railstips.org">Nunemaker's</a> tests.</p>
<p>In Perl, we don't have a REPL loop that's as good.  We can do a simple eval shell but it's not as polished nor as often used.</p>
<h2>Conclusion</h2><br />
I can't really give one.  There's no final argument, no silver bullet.  There are many things that I have gotten used to in Ruby and switching to Perl, even for this post is very difficult.  I'm faster in Ruby now than I was in Perl.  I'm fairly sure that I couldn't be as fast or elegant in Perl.  But it's not just the language, it's the REPL experience.  It's "gem list" vs CPAN.  It's the community of test-driven-development and a whole bunch of other soft features.  None of it is a deal breaker and Perl isn't failing to solve real problems everyday.  Perl is portable, well established, installed by default and it excels at text manipulation.  But I would say, despite all the good of Perl, Ruby sucks less.
</pre></pre>

  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">Squarism</h2>

    <div class="footer-col-1 column">
      <ul>
        <li>Squarism</li>
        <li><a href="mailto:squarism@gmail.com">squarism@gmail.com</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/squarism">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">squarism</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/squarism">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username">squarism</span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">A tech blog about ruby, code, mongodb, golang and other stuff.</p>
    </div>

  </div>

</footer>


    </body>
</html>